package dwins.geoscala

import java.io.File
import java.io.Serializable

import org.geotools.data.FeatureSource
import org.geotools.factory.CommonFactoryFinder
import org.geotools.factory.GeoTools
import org.geotools.feature.FeatureCollection
import org.geotools.styling.SLDTransformer
import org.geotools.styling.Style

import org.opengis.feature.simple.SimpleFeature
import org.opengis.feature.simple.SimpleFeatureType

object ColorRamp extends GeoCrunch {
  def pairwise[A](s: List[A]): List[(A,A)] = s zip (s drop 1)

  def ranges(col: FeatureCollection[SimpleFeatureType, SimpleFeature], 
    p: String) : List[(Double, Double)] = {
    // Use the value for the first feature as the starting value 
    // for both max and min

    var min = Math.NEG_INF_DOUBLE
    var max = Math.POS_INF_DOUBLE

    foreach (col) { f => 
      val current = f.getAttribute(p).asInstanceOf[Double]
      min = Math.min(min, current)
      max = Math.max(max, current)
    }

    // find a position on the ramp by taking a weighted 
    // average of the max and min values.
    def ramp(weight: Double) = min + (max - min) * weight

    // create 10 pairs representing ranges between min and max, linearly spaced
    pairwise((0 to 10).toList.map(x => ramp(x / 10d)))
  }

  def colorRamp(s: FeatureSource[SimpleFeatureType,SimpleFeature],
    property: String): Style = {
    val styles = CommonFactoryFinder.getStyleFactory(null)
    val filters = CommonFactoryFinder.getFilterFactory(null)

    def rule(x: ((Double, Double), Int)): org.geotools.styling.Rule = {
      val range = x._1
      val index = x._2

      val rule = styles.createRule
      rule.setFilter(filters.between(
        filters.property(property),
        filters.literal(range._1),
        filters.literal(range._2)
      ))
      val color = java.awt.Color.getHSBColor(index/10.0f, 0.5f, 0.75f)
      val colorExpr = filters.literal("#%2x%2x%2x".format(
        color.getRed,
        color.getGreen,
        color.getBlue)
      )
      rule.symbolizers.add(styles.createPolygonSymbolizer(
        styles.getDefaultStroke,
        styles.createFill(colorExpr),
        null
      ))
      rule.setName("%s#%d".format(property, index))
      rule.setTitle("%s in [%.1f <-> %.1f]".format(
        property, range._1, range._2
      ))
      rule.setAbstract("Values of %s between %.1f and %.1f".format(
        property, range._1, range._2
      ))
      return rule
    }

    val style = styles.createStyle
    style.setName(s.getSchema.getTypeName)
    style.setTitle("Color Ramp for %s".format(s.getSchema.getTypeName))
    style.setAbstract("Autogenerated color ramp for %s based on %s".format(
      s.getSchema.getTypeName, property
    ))

    val ramp = ranges(s.getFeatures, property)
    val ftStyle = 
      styles.createFeatureTypeStyle(ramp.zipWithIndex.map(rule).toArray)
    style.featureTypeStyles.add(ftStyle)

    return style
  }

  def main(args: Array[String]) = {
    println("Welcome to GeoTools:" + GeoTools.getVersion());

    val file = promptOpenFile(new javax.swing.filechooser.FileFilter() {
        def accept(f: File): Boolean = {
          f.isDirectory || f.getPath.toLowerCase.endsWith("shp")
        }

        def getDescription(): String = "ShapeFiles"
    })

    // Connection parameters
    val connectParameters: Map[String, Serializable] = Map(
      "url" -> file.toURI.toURL,
      "create spatial index" -> true
    )

    val dataStore = connect(connectParameters)

    // we are now connected
    val typeNames = dataStore.getTypeNames()
    val typeName = typeNames.elements.next

    println("Reading content " + typeName);

    val featureSource = dataStore.getFeatureSource(typeName)

    val xformer = new SLDTransformer
    val sld = promptSaveFile(new javax.swing.filechooser.FileFilter() {
        def accept(f: File): Boolean = {
          f.isDirectory || 
          f.getPath.toLowerCase.endsWith("sld") ||
          f.getPath.toLowerCase.endsWith("xml")
        }

        def getDescription(): String = "SLD (Styled Layer Descriptor)"
    })

    val sldStream = new java.io.FileOutputStream(sld)

    xformer.setIndentation(2)
    xformer.transform(colorRamp(featureSource, "PERSONS"), sldStream)
  }
}
